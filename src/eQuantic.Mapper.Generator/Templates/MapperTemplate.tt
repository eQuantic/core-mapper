<#@ template language="C#" visibility="internal" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="eQuantic.Mapper.Generator.Extensions" #>
<#
    var asyncPrefix = asynchronous ? "Async" : "";
    var className = mapperInfo.MapperClass.Name;
    var srcClassName = GetClassName(mapperInfo.SourceClass);
    var srcProperties = GetProperties(mapperInfo.SourceClass);
    var destClassName = GetClassName(mapperInfo.DestinationClass);
    var destProperties = GetProperties(mapperInfo.DestinationClass);
    var hasContext = mapperInfo.ContextClass != null;
    var ctxClassName = hasContext ? GetClassName(mapperInfo.ContextClass!) : "";
    var interfaceName = $"I{asyncPrefix}Mapper<{srcClassName}, {destClassName}{(hasContext ? ", "+ctxClassName: "")}>";
    var returnTypeName = asynchronous ? $"Task<{destClassName}?>" : $"{destClassName}?";
    var namespaces = GetNamespaces();
#>
//This file was generated by eQuantic.Mapper.Generator
<#
    foreach (var ns in namespaces)
    {
#>
using <#= ns #>;
<#
    }
#>

namespace <#= mapperInfo.MapperClass.FullNamespace()! #>
{
    public partial class <#= className #> : <#= interfaceName #>
    {
		#nullable enable
		/// <summary>
		/// The event before map
		/// </summary>
		public event OnMapHandler<#= asyncPrefix #><<#= srcClassName #>, <#= destClassName #>>? OnBeforeMap;

		/// <summary>
		/// The event after map
		/// </summary>
		public event OnMapHandler<#= asyncPrefix #><<#= srcClassName #>, <#= destClassName #>>? OnAfterMap;
		
        /// <summary>
		/// The mapper factory
		/// </summary>
        protected readonly IMapperFactory? MapperFactory;
		#nullable disable

<#
    if (hasContext)
    {
#>
		#nullable enable
		/// <summary>
	    /// Gets or sets the value of the context
	    /// </summary>
		public <#= ctxClassName #>? Context { get; set; }
		#nullable disable

<#
    }

    if (!mapperInfo.OmitConstructor)
    {
#>
		public <#= className #>(IMapperFactory mapperFactory)
		{
			MapperFactory = mapperFactory;
			AfterConstructor();
		}
<#
    }
#>
        
		#nullable enable
		public virtual <#= returnTypeName #> Map<#= asyncPrefix #>(<#= srcClassName #>? source<#= asynchronous ? ", CancellationToken cancellationToken = default": "" #>)
		{
			return Map<#= asyncPrefix #>(source, new <#= destClassName #>()<#= asynchronous ? ", cancellationToken": "" #>);
		}
		#nullable disable

		#nullable enable
		public virtual <#= asynchronous ? "async ": "" #><#= returnTypeName #> Map<#= asyncPrefix #>(<#= srcClassName #>? source, <#= destClassName #>? destination<#= asynchronous ? ", CancellationToken cancellationToken = default": "" #>)
		{
			if (source == null)
			{
				return null;
			}

			if (destination == null)
			{
				return <#= asynchronous ? "await ": "" #>Map<#= asyncPrefix #>(source<#= asynchronous ? ", cancellationToken": "" #>);
			}
<#
    if (asynchronous)
    {
#>
			await InvokeHandlerAsync(OnBeforeMap, new MapEventArgs<<#= srcClassName #>, <#= destClassName #>>(source, destination));
<#
    }
    else
    {
#>
			InvokeHandler(OnBeforeMap, new MapEventArgs<<#= srcClassName #>, <#= destClassName #>>(source, destination));
<#
    }
#>

<#
    foreach (var destProperty in destProperties)
    {
        var propertyCode = WritePropertySet(srcProperties, destProperty);
        if (!string.IsNullOrEmpty(propertyCode))
        {
#>
<#= propertyCode #>
<#
        }
    }

    if (asynchronous)
    {
#>
			await InvokeHandlerAsync(OnAfterMap, new MapEventArgs<<#= srcClassName #>, <#= destClassName #>>(source, destination));
<#
    }
    else
    {
#>
			InvokeHandler(OnAfterMap, new MapEventArgs<<#= srcClassName #>, <#= destClassName #>>(source, destination));
<#
    }
#>

			return destination;
		}
		#nullable disable

		partial void AfterConstructor();

<#
    if (asynchronous)
    {
#>
		#nullable enable
		private async Task InvokeHandlerAsync(OnMapHandlerAsync<<#= srcClassName #>, <#= destClassName #>>? handler, MapEventArgs<<#= srcClassName #>, <#= destClassName #>> eventArgs)
	    {
	        if (handler == null)
	        {
	            return;
	        }

	        var invocationList = handler.GetInvocationList();
	        var handlerTasks = new Task[invocationList.Length];

	        for (var i = 0; i < invocationList.Length; i++)
	        {
				var invocationItem = Delegate.CreateDelegate(typeof(Func<object, MapEventArgs<<#= srcClassName #>, <#= destClassName #>>, Task>),
                	invocationList[i].Target, invocationList[i].Method);
	            handlerTasks[i] = ((Func<object, MapEventArgs<<#= srcClassName #>, <#= destClassName #>>, Task>)invocationItem)(this, eventArgs);
	        }

	        await Task.WhenAll(handlerTasks);
	    }
		#nullable disable
<#
    }
    else
    {
#>
		#nullable enable
		private void InvokeHandler(OnMapHandler<<#= srcClassName #>, <#= destClassName #>>? handler, MapEventArgs<<#= srcClassName #>, <#= destClassName #>> eventArgs)
	    {
			if (handler == null)
	        {
	            return;
	        }

			handler(this, eventArgs);
		}
		#nullable disable
<#
    }
#>
    }
}