using System.Diagnostics;
using System.Text;
using System.Text.RegularExpressions;
using eQuantic.Mapper.Generator.Extensions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace eQuantic.Mapper.Generator;

[Generator]
public sealed class MapperGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
#if DEBUG
        SpinWait.SpinUntil(() => Debugger.IsAttached);
#endif 
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        // retrieve the populated receiver 
        if (context.SyntaxContextReceiver is not SyntaxReceiver receiver)
            return;

        foreach (var mapperInfo in receiver.Infos)
        {
            var className = GetMapperClassName(mapperInfo);
            var srcClassName = mapperInfo.SourceClass.Name;
            var srcProperties = mapperInfo.SourceClass.ReadWriteScalarProperties().ToList();
            var destClassName = mapperInfo.DestinationClass.Name;
            var destProperties = mapperInfo.DestinationClass.ReadWriteScalarProperties().ToList();
            var baseClassName = "MapperBase<" + srcClassName + ", " + destClassName + ">";
            var fileName = className + ".g.cs";
            var code = new CodeWriter();

            code.AppendLine("//This file was generated by eQuantic.Mapper.Generator");
            code.AppendLine();

            var namespaces = new HashSet<string>
            {
                "System",
                mapperInfo.SourceClass.FullNamespace(),
                mapperInfo.DestinationClass.FullNamespace()
            };

            foreach (var ns in namespaces)
            {
                code.AppendLine($"using {ns};");
            }

            using (code.BeginScope($"namespace {mapperInfo.MapperClass.FullNamespace()}"))
            {
                using (code.BeginScope("public partial class {0} : {1}", className, baseClassName))
                {
                    code.AppendSummary("The mapper factory");
                    code.AppendLine("private readonly IMapperFactory _mapperFactory;");
                    code.AppendLine();

                    using (code.BeginScope("public {0}(IMapperFactory mapperFactory)", className))
                    {
                        code.AppendLine("_mapperFactory = mapperFactory;");
                    }

                    code.AppendLine();

                    using (code.BeginScope("public override {0} Map({1} source)", destClassName, srcClassName))
                    {
                        code.AppendLine($"return Map(source, new {destClassName}());");
                    }

                    using (code.BeginScope("public override {0} Map({1} source, {0} destination)", destClassName, srcClassName))
                    {
                        code.AppendLine("destination = BeforeMap(source, destination);");
                        code.AppendLine("if(destination == null) return null;");
                        code.AppendLine();

                        foreach (var destProperty in destProperties)
                        {
                            WritePropertySet(code, srcProperties, destProperty);
                        }
                        code.AppendLine();
                        code.AppendLine("AfterMap(source, destination);");
                        code.AppendLine("return destination;");
                    }
                }
            }

            context.AddSource(fileName, SourceText.From(code.ToString(), new UTF8Encoding(false)));
        }
    }

    private static void WritePropertySet(CodeWriter code, IEnumerable<IPropertySymbol> srcProperties, IPropertySymbol destProperty)
    {
        var srcProperty = srcProperties.FirstOrDefault(o =>
            o.Name.Equals(destProperty.Name, StringComparison.InvariantCultureIgnoreCase));

        if (srcProperty == null)
            return;

        if (srcProperty.Type.Name == nameof(String) && 
            destProperty.Type.Name != nameof(String) && 
            destProperty.Type.IsValueType)
        {
            switch (destProperty.Type.Name)
            {
                case nameof(DateTime):
                    code.AppendLine("destination.{0} = DateTime.Parse(source.{1});", destProperty.Name, srcProperty.Name);
                    break;
                default:
                    code.AppendLine("destination.{0} = Convert.To{1}(source.{2});", destProperty.Name, destProperty.Type.Name, srcProperty.Name);
                    break;
            }

            return;
        }
        code.AppendLine($"destination.{destProperty.Name} = source.{srcProperty.Name};");
    }
    private static string GetMapperClassName(MapperInfo mapperInfo)
    {
        var name = mapperInfo.MapperClass.Name;
        if (string.IsNullOrEmpty(name))
            return "Default";

        name = TrimEnd(name, "Config");
        name = TrimEnd(name, "Configuration");
        
        return Regex.IsMatch(name, @"Mapper$") ? name : $"{name}Mapper";
    }

    private static string TrimEnd(string str, string term)
    {
        return Regex.Replace(str, term + @"$", "");
    }
}