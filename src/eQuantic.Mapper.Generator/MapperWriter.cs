using eQuantic.Mapper.Generator.Extensions;
using eQuantic.Mapper.Generator.Strategies;
using Microsoft.CodeAnalysis;

namespace eQuantic.Mapper.Generator;

/// <summary>
/// Writes mapper class code using CodeWriter instead of T4 templates.
/// </summary>
internal class MapperWriter(MapperInfo mapperInfo, bool asynchronous)
{
    private static readonly HashSet<string> ProcessedTypes = [];

    public string GenerateMapper()
    {
        var writer = new CodeWriter(indentLevel: 0, indentationType: IndentationType.Spaces);
        
        // Generate header comment
        writer.AppendLine("//This file was generated by eQuantic.Mapper.Generator");
        
        // Generate using statements
        var namespaces = GetNamespaces();
        foreach (var ns in namespaces)
        {
            writer.AppendLine($"using {ns};");
        }
        
        writer.AppendLine();
        
        // Generate namespace and class
        var className = mapperInfo.MapperClass.Name;
        var srcClassName = GetClassName(mapperInfo.SourceClass);
        var destClassName = GetClassName(mapperInfo.DestinationClass);
        var hasContext = mapperInfo.ContextClass != null;
        var ctxClassName = hasContext ? GetClassName(mapperInfo.ContextClass!) : "";
        var asyncPrefix = asynchronous ? "Async" : "";
        var interfaceName = $"I{asyncPrefix}Mapper<{srcClassName}, {destClassName}{(hasContext ? ", " + ctxClassName : "")}>";
        
        // Generate namespace
        using (writer.BeginScope($"namespace {mapperInfo.MapperClass.FullNamespace()!}"))
        {
            // Generate class documentation and declaration
            writer.AppendXmlDocSummary($"Mapper implementation for converting {srcClassName} to {destClassName}");
            using (writer.BeginScope($"public partial class {className} : {interfaceName}"))
            {
                GenerateClassContent(writer, className, srcClassName, destClassName, hasContext, ctxClassName, asyncPrefix);
            }
        }
        
        var result = writer.ToString();
        // Remove trailing newline to match test expectation
        return result.TrimEnd('\n', '\r');
    }

    private void GenerateClassContent(CodeWriter writer, string className, string srcClassName, string destClassName, bool hasContext, string ctxClassName, string asyncPrefix)
    {
        // Generate events and properties using consistent space indentation
        writer.AppendLine("#nullable enable");
        writer.AppendXmlDocSummary("The event before map");
        writer.AppendLine($"public event OnMapHandler{asyncPrefix}<{srcClassName}, {destClassName}>? OnBeforeMap;");
        writer.AppendLine();
        
        writer.AppendXmlDocSummary("The event after map");
        writer.AppendLine($"public event OnMapHandler{asyncPrefix}<{srcClassName}, {destClassName}>? OnAfterMap;");
        writer.AppendLine();
        
        writer.AppendXmlDocSummary("The mapper factory");
        writer.AppendLine("protected readonly IMapperFactory? MapperFactory;");
        writer.AppendLine("#nullable disable");
        writer.AppendLine();

        // Generate context property if needed
        if (hasContext)
        {
            writer.AppendLine("#nullable enable");
            writer.AppendXmlDocSummary("Gets or sets the value of the context");
            writer.AppendLine($"public {ctxClassName}? Context {{ get; set; }}");
            writer.AppendLine("#nullable disable");
            writer.AppendLine();
        }

        // Generate constructor if not omitted
        if (!mapperInfo.OmitConstructor)
        {
            writer.AppendXmlDocSummary($"Initializes a new instance of the {className} class");
            writer.AppendXmlDocParam("mapperFactory", "The mapper factory for creating nested mappers");
            using (writer.BeginScope($"public {className}(IMapperFactory mapperFactory)"))
            {
                writer.AppendLine("MapperFactory = mapperFactory;");
                writer.AppendLine("AfterConstructor();");
            }
            // Add spacing line using proper CodeWriter methods  
            writer.AppendLine();
        }

        // Generate Map methods
        GenerateMapMethods(writer, srcClassName, destClassName, asyncPrefix);
        
        // Generate partial method
        writer.AppendXmlDocSummary("Called after the constructor completes to allow custom initialization");
        writer.AppendLine("partial void AfterConstructor();");
        writer.AppendLine();
        
        // Generate invoke handler methods
        GenerateInvokeHandlerMethods(writer, srcClassName, destClassName, asyncPrefix);
    }

    private void GenerateMapMethods(CodeWriter writer, string srcClassName, string destClassName, string asyncPrefix)
    {
        var returnTypeName = asynchronous ? $"Task<{destClassName}?>" : $"{destClassName}?";
        var cancellationParam = asynchronous ? ", CancellationToken cancellationToken = default" : "";
        var cancellationArg = asynchronous ? ", cancellationToken" : "";
        var awaitKeyword = asynchronous ? "await " : "";
        var asyncKeyword = asynchronous ? "async " : "";

        // First Map method
        writer.AppendLine("#nullable enable");
        writer.AppendXmlDocSummary($"Maps a {srcClassName} to a new {destClassName}");
        writer.AppendXmlDocParam("source", "The source object to map from");
        if (asynchronous)
        {
            writer.AppendXmlDocParam("cancellationToken", "Cancellation token");
        }
        writer.AppendXmlDocReturns($"A new {destClassName} with mapped values");
        using (writer.BeginScope($"public virtual {returnTypeName} Map{asyncPrefix}({srcClassName}? source{cancellationParam})"))
        {
            writer.AppendLine($"return Map{asyncPrefix}(source, new {destClassName}(){cancellationArg});");
        }
        writer.AppendLine("#nullable disable");
        writer.AppendLine();

        // Second Map method
        writer.AppendLine("#nullable enable");
        writer.AppendXmlDocSummary($"Maps a {srcClassName} to an existing {destClassName}");
        writer.AppendXmlDocParam("source", "The source object to map from");
        writer.AppendXmlDocParam("destination", "The destination object to map to");
        if (asynchronous)
        {
            writer.AppendXmlDocParam("cancellationToken", "Cancellation token");
        }
        writer.AppendXmlDocReturns($"The updated destination object");
        using (writer.BeginScope($"public virtual {asyncKeyword}{returnTypeName} Map{asyncPrefix}({srcClassName}? source, {destClassName}? destination{cancellationParam})"))
        {
            using (writer.BeginScope("if (source == null)"))
            {
                writer.AppendLine("return null;");
            }
            writer.AppendLine();

            using (writer.BeginScope("if (destination == null)"))
            {
                writer.AppendLine($"return {awaitKeyword}Map{asyncPrefix}(source{cancellationArg});");
            }

            // Generate event invocation
            var invokeMethod = asynchronous ? "InvokeHandlerAsync" : "InvokeHandler";
            var awaitInvoke = asynchronous ? "await " : "";
            writer.AppendLine($"{awaitInvoke}{invokeMethod}(OnBeforeMap, new MapEventArgs<{srcClassName}, {destClassName}>(source, destination));");
            writer.AppendLine();

            // Generate property mappings
            GeneratePropertyMappings(writer);

            // Generate after event invocation
            writer.AppendLine($"{awaitInvoke}{invokeMethod}(OnAfterMap, new MapEventArgs<{srcClassName}, {destClassName}>(source, destination));");
            writer.AppendLine();
            writer.AppendLine("return destination;");
        }
        writer.AppendLine("#nullable disable");
        writer.AppendLine();
    }

    private void GeneratePropertyMappings(CodeWriter writer)
    {
        var srcProperties = GetProperties(mapperInfo.SourceClass);
        var destProperties = GetProperties(mapperInfo.DestinationClass);

        foreach (var destProperty in destProperties)
        {
            WritePropertySet(writer, srcProperties, destProperty);
        }
    }

    private void GenerateInvokeHandlerMethods(CodeWriter writer, string srcClassName, string destClassName, string asyncPrefix)
    {
        if (asynchronous)
        {
            writer.AppendLine("#nullable enable");
            using (writer.BeginScope($"private async Task InvokeHandlerAsync(OnMapHandlerAsync<{srcClassName}, {destClassName}>? handler, MapEventArgs<{srcClassName}, {destClassName}> eventArgs)"))
            {
                using (writer.BeginScope("if (handler == null)"))
                {
                    writer.AppendLine("return;");
                }
                writer.AppendLine();

                writer.AppendLine("var invocationList = handler.GetInvocationList();");
                writer.AppendLine("var handlerTasks = new Task[invocationList.Length];");
                writer.AppendLine();

                using (writer.BeginScope("for (var i = 0; i < invocationList.Length; i++)"))
                {
                    writer.AppendLine($"var invocationItem = Delegate.CreateDelegate(typeof(Func<object, MapEventArgs<{srcClassName}, {destClassName}>, Task>),");
                    writer.AppendLine("    invocationList[i].Target, invocationList[i].Method);");
                    writer.AppendLine($"handlerTasks[i] = ((Func<object, MapEventArgs<{srcClassName}, {destClassName}>, Task>)invocationItem)(this, eventArgs);");
                }
                writer.AppendLine();
                writer.AppendLine("await Task.WhenAll(handlerTasks);");
            }
            writer.AppendLine("#nullable disable");
        }
        else
        {
            // Generate InvokeHandler using proper CodeWriter methods
            writer.AppendLine("#nullable enable");
            using (writer.BeginScope($"private void InvokeHandler(OnMapHandler<{srcClassName}, {destClassName}>? handler, MapEventArgs<{srcClassName}, {destClassName}> eventArgs)"))
            {
                using (writer.BeginScope("if (handler == null)"))
                {
                    writer.AppendLine("return;");
                }
                writer.AppendLine();
                writer.AppendLine("handler(this, eventArgs);");
            }
            writer.AppendLine("#nullable disable");
        }
    }

    private void WritePropertySet(CodeWriter writer, IList<IPropertySymbol> srcProperties, IPropertySymbol destProperty)
    {
        var mapFrom = destProperty
            .GetAttributes()
            .FirstOrDefault(o => o.AttributeClass?.FullName() == "eQuantic.Mapper.Attributes.MapFromAttribute");
        var mapFromSrcClass = (INamedTypeSymbol?)mapFrom?.ConstructorArguments[0].Value;
        var mapFromSrcPropNames = GetPropertyNamesFromAttribute(mapFrom);

        if (mapFromSrcClass != null && mapFromSrcClass.FullName() == mapperInfo.SourceClass.FullName())
        {
            // Handle multiple properties with aggregation
            if (mapFromSrcPropNames.Length > 1 && mapFrom != null)
            {
                WriteAggregatedPropertySet(writer, srcProperties, destProperty, mapFrom);
                return;
            }
            
            // Handle single property mapping (including nested properties)
            if (mapFromSrcPropNames.Length == 1)
            {
                var propName = mapFromSrcPropNames[0];
                
                if (propName.Contains('.'))
                {
                    // Nested property (e.g., "Address.Number")
                    WriteNestedPropertySetWithPath(writer, propName, destProperty);
                    return;
                }

                // Simple property
                var mapFromSrcProperty = srcProperties.FirstOrDefault(o =>
                    string.Equals(o.Name, propName, StringComparison.InvariantCultureIgnoreCase));

                if (mapFromSrcProperty != null)
                {
                    WritePropertySet(writer, mapFromSrcProperty, destProperty);
                    return;
                }
            }
        }

        var srcProperty = srcProperties.FirstOrDefault(o =>
            o.Name.Equals(destProperty.Name, StringComparison.InvariantCultureIgnoreCase));

        if (srcProperty != null)
        {
            WritePropertySet(writer, srcProperty, destProperty);
        }
    }

    private void WritePropertySet(CodeWriter writer, IPropertySymbol srcProperty, IPropertySymbol destProperty)
    {
        var context = new PropertyMappingContext
        {
            SourceProperty = srcProperty,
            DestinationProperty = destProperty,
            VerifyNullability = mapperInfo.VerifyNullability,
            IsAsync = asynchronous,
            SourceVariableName = "source",
            DestinationVariableName = "destination"
        };

        // Use the writer directly without creating new instance - indentation is already set
        PropertyStrategyFactory.GenerateMapping(context, writer);
    }

    // Copy the remaining helper methods from MapperTemplate.partial.cs
    private void WriteNestedPropertySetWithPath(CodeWriter writer, string propertyPath, IPropertySymbol destProperty)
    {
        // Generate assignment for nested property with proper nullability checks
        var nullabilityCheck = mapperInfo.VerifyNullability && 
                               (destProperty.Type.CanBeReferencedByName || destProperty.NullableAnnotation == NullableAnnotation.Annotated);
        
        // Use the writer directly without creating new instance - indentation is already set by caller
        if (nullabilityCheck)
        {
            var nullCheck = BuildNestedNullabilityCheck(propertyPath);
            var propertyAccessor = BuildNestedPropertyAccessorWithoutNullCheck(propertyPath);
            
            // For string properties, also check if the value is not null or empty
            var isStringProperty = destProperty.Type.IsString();
            if (isStringProperty)
            {
                nullCheck += $" && !string.IsNullOrEmpty({propertyAccessor})";
            }
            
            using (writer.BeginScope($"if ({nullCheck})"))
            {
                writer.AppendLine($"destination.{destProperty.Name} = {propertyAccessor};");
            }
        }
        else
        {
            // Use null-conditional operators when not doing explicit nullability checks
            // But handle nullable to non-nullable conversions
            var propertyAccessor = BuildNestedPropertyAccessor(propertyPath);
            
            // Check if we need to handle nullable to non-nullable conversion
            if (!destProperty.Type.IsNullable())
            {
                if (destProperty.Type.IsString())
                {
                    writer.AppendLine($"destination.{destProperty.Name} = {propertyAccessor} ?? string.Empty;");
                }
                else if (destProperty.Type.IsNumeric() || destProperty.Type.IsBoolean() || destProperty.Type.Is<Guid>() || destProperty.Type.Is<DateTime>())
                {
                    var defaultValue = destProperty.Type.GetDefaultValue();
                    writer.AppendLine($"destination.{destProperty.Name} = {propertyAccessor} ?? {defaultValue};");
                }
                else
                {
                    writer.AppendLine($"destination.{destProperty.Name} = {propertyAccessor} ?? default;");
                }
            }
            else
            {
                writer.AppendLine($"destination.{destProperty.Name} = {propertyAccessor};");
            }
        }
    }

    private void WriteAggregatedPropertySet(CodeWriter writer, IList<IPropertySymbol> srcProperties, IPropertySymbol destProperty, AttributeData mapFromAttribute)
    {
        var mapFromSrcPropNames = GetPropertyNamesFromAttribute(mapFromAttribute);
        var aggregationValue = mapFromAttribute.ConstructorArguments.Length > 2 ? 
            (int)mapFromAttribute.ConstructorArguments[2].Value! : 0; // 0 = None
        var separator = mapFromAttribute.ConstructorArguments.Length > 3 ? 
            (string?)mapFromAttribute.ConstructorArguments[3].Value : null;

        // Handle both simple properties and nested properties (with dots)
        var propertyAccessors = new List<string>();
        var propertyPaths = new List<string>(); // Keep track of original paths for nullability checks
        
        foreach (var propName in mapFromSrcPropNames)
        {
            if (propName.Contains('.'))
            {
                // Nested property (e.g., "Address.Number")
                var accessor = BuildNestedPropertyAccessor(propName);
                
                if (string.IsNullOrEmpty(accessor)) 
                    continue;
                
                propertyAccessors.Add(accessor);
            }
            else
            {
                // Simple property
                var matchedProperty = srcProperties.FirstOrDefault(p => 
                    string.Equals(p.Name, propName, StringComparison.InvariantCultureIgnoreCase));
                
                if (matchedProperty == null) 
                    continue;
                
                propertyAccessors.Add($"source.{matchedProperty.Name}");
            }

            propertyPaths.Add(propName);
        }

        if (!propertyAccessors.Any())
            return;

        // Generate aggregation code directly with property accessors
        GenerateAggregationCodeWithAccessors(writer, propertyAccessors, propertyPaths, destProperty, aggregationValue, separator);
    }

    // Copy all the helper methods from MapperTemplate.partial.cs
    private static string[] GetPropertyNamesFromAttribute(AttributeData? mapFromAttribute)
    {
        if (mapFromAttribute == null || mapFromAttribute.ConstructorArguments.Length < 2)
            return [];

        var secondArg = mapFromAttribute.ConstructorArguments[1];
        
        // Check if it's an array (new syntax)
        if (secondArg is { IsNull: false, Kind: TypedConstantKind.Array })
        {
            return secondArg.Values.Select(v => v.Value?.ToString()).Where(v => v != null).ToArray()!;
        }
        
        // Check if it's a single string (old syntax for backward compatibility)
        if (!secondArg.IsNull && secondArg.Value is string singleProperty)
        {
            return [singleProperty];
        }

        return [];
    }

    private static string BuildNestedPropertyAccessor(string propertyPath)
    {
        // Build nested property accessor with null checking
        // e.g., "Address.Number" becomes "source.Address?.Number"
        var parts = propertyPath.Split('.');
        if (parts.Length < 2) return string.Empty;

        var accessor = "source";
        for (var i = 0; i < parts.Length; i++)
        {
            if (i == parts.Length - 1)
            {
                // Last property - no null check needed
                accessor += $".{parts[i]}";
            }
            else
            {
                // Intermediate properties - add null check
                accessor += $".{parts[i]}?";
            }
        }

        return accessor;
    }

    private static string BuildNestedNullabilityCheck(string propertyPath)
    {
        // Build null checks for nested properties
        // e.g., "Address.Country.Name" becomes "source != null && source.Address != null && source.Address.Country != null"
        var parts = propertyPath.Split('.');
        if (parts.Length < 2) return "source != null";

        var checks = new List<string> { "source != null" };
        var currentPath = "source";
        
        for (var i = 0; i < parts.Length - 1; i++)
        {
            currentPath += $".{parts[i]}";
            checks.Add($"{currentPath} != null");
        }

        return string.Join(" && ", checks);
    }

    private static string BuildNestedPropertyAccessorWithoutNullCheck(string propertyPath)
    {
        // Build property accessor without null-conditional operators for use inside null checks
        // e.g., "Address.Number" becomes "source.Address.Number"
        var parts = propertyPath.Split('.');
        if (parts.Length < 2) return string.Empty;

        return "source." + string.Join(".", parts);
    }

    private void GenerateAggregationCodeWithAccessors(CodeWriter writer, List<string> propertyAccessors, List<string> propertyPaths, IPropertySymbol destProperty, int aggregationValue, string? separator)
    {
        var propertyAccess = string.Join(", ", propertyAccessors);
        var nullabilityCheck = mapperInfo.VerifyNullability && 
                               (destProperty.Type.CanBeReferencedByName || destProperty.NullableAnnotation == NullableAnnotation.Annotated);

        // Use the writer directly without creating new instance - indentation is already set by caller

        // Helper method to handle nullable to non-nullable conversion for aggregation results
        string GetAggregationAssignment(string expression, bool canReturnNull = false)
        {
            if (canReturnNull && !destProperty.Type.IsNullable())
            {
                if (destProperty.Type.IsString())
                {
                    return $"destination.{destProperty.Name} = ({expression}) ?? string.Empty;";
                }
                else if (destProperty.Type.IsNumeric() || destProperty.Type.IsBoolean() || destProperty.Type.Is<Guid>() || destProperty.Type.Is<DateTime>())
                {
                    var defaultValue = destProperty.Type.GetDefaultValue();
                    return $"destination.{destProperty.Name} = ({expression}) ?? {defaultValue};";
                }
                else
                {
                    return $"destination.{destProperty.Name} = ({expression}) ?? default;";
                }
            }
            else
            {
                return $"destination.{destProperty.Name} = {expression};";
            }
        }

        var code = aggregationValue switch
        {
            1 => GetAggregationAssignment($"string.Join(\"\", new object?[] {{ {propertyAccess} }}.Where(x => x != null && !string.IsNullOrEmpty(x.ToString())).Select(x => x.ToString()))"), // Concatenate - string.Join never returns null
            2 => GetAggregationAssignment($"string.Join(\" \", new object?[] {{ {propertyAccess} }}.Where(x => x != null && !string.IsNullOrEmpty(x.ToString())).Select(x => x.ToString()))"), // ConcatenateWithSpace
            3 => GetAggregationAssignment($"string.Join(\", \", new object?[] {{ {propertyAccess} }}.Where(x => x != null && !string.IsNullOrEmpty(x.ToString())).Select(x => x.ToString()))"), // ConcatenateWithComma
            4 => GetAggregationAssignment($"string.Join(\"{separator ?? ""}\", new object?[] {{ {propertyAccess} }}.Where(x => x != null && !string.IsNullOrEmpty(x.ToString())).Select(x => x.ToString()))"), // ConcatenateWithSeparator
            5 => GetAggregationAssignment($"new[] {{ {propertyAccess} }}.Sum()"), // Sum
            6 => GetAggregationAssignment($"new[] {{ {propertyAccess} }}.Max()"), // Max
            7 => GetAggregationAssignment($"new[] {{ {propertyAccess} }}.Min()"), // Min
            8 => GetAggregationAssignment($"new[] {{ {propertyAccess} }}.Average()"), // Average
            9 => GetAggregationAssignment($"new object?[] {{ {propertyAccess} }}.Where(x => x != null && !string.IsNullOrEmpty(x.ToString())).FirstOrDefault()?.ToString()", true), // FirstNonEmpty - can return null
            10 => GetAggregationAssignment($"new object?[] {{ {propertyAccess} }}.Where(x => x != null && !string.IsNullOrEmpty(x.ToString())).LastOrDefault()?.ToString()", true), // LastNonEmpty - can return null
            11 => GetAggregationAssignment($"new object?[] {{ {propertyAccess} }}.Count(x => x != null)"), // Count
            _ => string.Empty
        };

        if (nullabilityCheck && !string.IsNullOrEmpty(code))
        {
            // Generate comprehensive null checks for all nested properties
            var allNullChecks = new List<string> { "source != null" };
            
            foreach (var path in propertyPaths)
            {
                if (!path.Contains('.')) 
                    continue;
                
                // For nested properties, add all intermediate null checks
                var parts = path.Split('.');
                var currentPath = "source";
                    
                for (var i = 0; i < parts.Length - 1; i++)
                {
                    currentPath += $".{parts[i]}";
                    if (!allNullChecks.Contains($"{currentPath} != null"))
                    {
                        allNullChecks.Add($"{currentPath} != null");
                    }
                }
            }
            
            var combinedNullCheck = string.Join(" && ", allNullChecks);
            
            using (writer.BeginScope($"if ({combinedNullCheck})"))
            {
                writer.AppendLine(code);
            }
        }
        else
        {
            writer.AppendLine(code);
        }
    }

    private static List<IPropertySymbol> GetProperties(ITypeSymbol? sourceClass)
    {
        if (sourceClass == null) return [];

        var list = GetProperties(sourceClass.BaseType);
        list.AddRange(sourceClass.ReadWriteScalarProperties());
        return list;
    }

    private static string GetClassName(INamedTypeSymbol namedTypeSymbol)
    {
        var classFullNamespace = namedTypeSymbol.FullNamespace();
        if (classFullNamespace!.Contains($".{namedTypeSymbol.Name}.") || classFullNamespace.EndsWith($".{namedTypeSymbol.Name}"))
            return $"{classFullNamespace}.{namedTypeSymbol.Name}";
        return namedTypeSymbol.Name;
    }

    private HashSet<string> GetNamespaces()
    {
        var namespaces = new HashSet<string>
        {
            "System",
            "System.Collections.Generic",
            "System.Linq",
            "eQuantic.Mapper"
        };
        if(asynchronous)
            namespaces.Add("System.Threading.Tasks");

        var srcClassFullNamespace = mapperInfo.SourceClass.FullNamespace();
        if (!string.IsNullOrEmpty(srcClassFullNamespace))
        {
            namespaces.Add(srcClassFullNamespace!);
        }

        var destClassFullNamespace = mapperInfo.DestinationClass.FullNamespace();
        if (!string.IsNullOrEmpty(destClassFullNamespace))
        {
            namespaces.Add(destClassFullNamespace!);
        }

        // Clear processed types for each mapper generation
        ProcessedTypes.Clear();
        
        var srcProperties = GetPropertiesNamespaces(mapperInfo.SourceClass);
        foreach (var srcPropertyNamespace in srcProperties)
        {
            if(!string.IsNullOrEmpty(srcPropertyNamespace))
                namespaces.Add(srcPropertyNamespace);
        }

        var destProperties = GetPropertiesNamespaces(mapperInfo.DestinationClass);
        foreach (var destPropertyNamespace in destProperties)
        {
            if(!string.IsNullOrEmpty(destPropertyNamespace))
                namespaces.Add(destPropertyNamespace);
        }

        return namespaces;
    }

    private static IEnumerable<string> GetPropertiesNamespaces(ITypeSymbol classType)
    {
        var namespaces = new HashSet<string>();
        var typeFullName = classType.TryFullName();
        
        // Prevent circular references by checking if we've already processed this type
        if (typeFullName != null && ProcessedTypes.Contains(typeFullName))
        {
            return namespaces;
        }
        
        if (typeFullName != null)
        {
            ProcessedTypes.Add(typeFullName);
        }
        
        var list = classType.ReadWriteScalarProperties();
        foreach (var symbol in list)
        {
            if(symbol.Type.IsPrimitive())
                continue;

            if (symbol.Type is INamedTypeSymbol namedTypeSymbol && namedTypeSymbol.TypeArguments.Any())
            {
                foreach (var ts in namedTypeSymbol.TypeArguments)
                {
                    var nmSpace = ts.FullNamespace();
                    if(!string.IsNullOrEmpty(nmSpace))
                        namespaces.Add(nmSpace!);

                    // Only recurse if we haven't processed this type yet
                    var tsFullName = ts.TryFullName();
                    
                    if (tsFullName == null || ProcessedTypes.Contains(tsFullName)) 
                        continue;
                    
                    var propertyNamespaces = GetPropertiesNamespaces(ts);
                    foreach (var propertyNamespace in propertyNamespaces)
                    {
                        namespaces.Add(propertyNamespace);
                    }
                }
            }

            var fullNamespace = symbol.Type.FullNamespace();
            if(string.IsNullOrEmpty(fullNamespace))
                continue;

            namespaces.Add(fullNamespace!);
        }

        return namespaces;
    }
}