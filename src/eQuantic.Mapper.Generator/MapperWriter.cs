using eQuantic.Mapper.Generator.Extensions;
using eQuantic.Mapper.Generator.Strategies;
using Microsoft.CodeAnalysis;

namespace eQuantic.Mapper.Generator;

/// <summary>
/// Writes mapper class code using CodeWriter instead of T4 templates.
/// </summary>
internal class MapperWriter(MapperInfo mapperInfo, bool asynchronous)
{
    private static readonly HashSet<string> ProcessedTypes = [];

    private class MapperDescriptor
    {
        public string MapperClassName { get; set; } = string.Empty;
        public INamedTypeSymbol SourceClass { get; set; } = null!;
        public string SourceClassName { get; set; } = string.Empty;
        public INamedTypeSymbol DestinationClass { get; set; } = null!;
        public string DestinationClassName { get; set; } = string.Empty;
        public bool HasContext { get; set; }
        public string ContextClassName { get; set; } = string.Empty;
        public bool IsAsync { get; set; }
        public string AsyncPrefix => IsAsync ? "Async" : "";
        public string InterfaceName { get; set; } = string.Empty;
        public bool OmitConstructor { get; set; }
        public bool VerifyNullability { get; set; }
        public bool IsBidirectional { get; set; }
        public int Index { get; set; }
    }

    public string GenerateMapper()
    {
        var writer = new CodeWriter(indentLevel: 0, indentationType: IndentationType.Spaces);

        // Generate header comment
        writer.AppendLine("//This file was generated by eQuantic.Mapper.Generator");

        // Generate using statements
        var namespaces = GetNamespaces();
        foreach (var ns in namespaces)
        {
            writer.AppendLine($"using {ns};");
        }

        writer.AppendLine();

        // Generate namespace and class

        var className = mapperInfo.MapperClass.Name;
        var srcClassName = GetClassName(mapperInfo.SourceClass);
        var destClassName = GetClassName(mapperInfo.DestinationClass);
        var hasContext = mapperInfo.ContextClass != null;
        var ctxClassName = hasContext ? GetClassName(mapperInfo.ContextClass!) : "";
        var asyncPrefix = asynchronous ? "Async" : "";

        var descriptors = new List<MapperDescriptor>();
        if (mapperInfo.MapperDirection is 0 or 3)
            descriptors.Add(new MapperDescriptor
            {
                MapperClassName = className,
                SourceClass = mapperInfo.SourceClass,
                SourceClassName = srcClassName,
                DestinationClass = mapperInfo.DestinationClass,
                DestinationClassName = destClassName,
                HasContext = hasContext,
                ContextClassName = ctxClassName,
                IsAsync = asynchronous,
                InterfaceName =
                    $"I{asyncPrefix}Mapper<{srcClassName}, {destClassName}{(hasContext ? ", " + ctxClassName : "")}>",
                OmitConstructor = mapperInfo.OmitConstructor,
                VerifyNullability = mapperInfo.VerifyNullability,
                IsBidirectional = mapperInfo.MapperDirection == 3,
                Index = descriptors.Count
            });
        if (mapperInfo.MapperDirection is 1 or 3)
            descriptors.Add(new MapperDescriptor
            {
                MapperClassName = className,
                SourceClass = mapperInfo.DestinationClass,
                SourceClassName = destClassName,
                DestinationClass = mapperInfo.SourceClass,
                DestinationClassName = srcClassName,
                HasContext = hasContext,
                ContextClassName = ctxClassName,
                IsAsync = asynchronous,
                InterfaceName =
                    $"I{asyncPrefix}Mapper<{destClassName}, {srcClassName}{(hasContext ? ", " + ctxClassName : "")}>",
                OmitConstructor = mapperInfo.OmitConstructor,
                VerifyNullability = mapperInfo.VerifyNullability,
                IsBidirectional = mapperInfo.MapperDirection == 3,
                Index = descriptors.Count
            });

        // Generate namespace
        using (writer.BeginScope($"namespace {mapperInfo.MapperClass.FullNamespace()!}"))
        {
            // Generate class documentation and declaration
            writer.AppendXmlDocSummary($"Mapper implementation for converting {srcClassName} to {destClassName}");
            using (writer.BeginScope(
                       $"public partial class {className} : {string.Join(", ", descriptors.Select(d => d.InterfaceName))}"))
            {
                foreach (var descriptor in descriptors)
                {
                    GenerateClassContent(writer, descriptor);
                }
            }
        }

        var result = writer.ToString();
        // Remove trailing newline to match test expectation
        return result.TrimEnd('\n', '\r');
    }

    private static void GenerateClassContent(CodeWriter writer, MapperDescriptor descriptor)
    {
        if (descriptor.Index == 0)
        {
            // Generate events and properties using consistent space indentation
            writer.AppendLine("#nullable enable");
            writer.AppendXmlDocSummary("The event before map");
            if (descriptor.IsBidirectional)
            {
                writer.AppendLine(
                    $"public event OnMapHandler{descriptor.AsyncPrefix}<{descriptor.SourceClassName}, {descriptor.DestinationClassName}>? OnBeforeForwardMap;");
                writer.AppendLine(
                    $"public event OnMapHandler{descriptor.AsyncPrefix}<{descriptor.DestinationClassName}, {descriptor.SourceClassName}>? OnBeforeReverseMap;");
            }
            else
            {
                writer.AppendLine(
                    $"public event OnMapHandler{descriptor.AsyncPrefix}<{descriptor.SourceClassName}, {descriptor.DestinationClassName}>? OnBeforeMap;");
            }

            writer.AppendLine();

            writer.AppendXmlDocSummary("The event after map");
            if (descriptor.IsBidirectional)
            {
                writer.AppendLine(
                    $"public event OnMapHandler{descriptor.AsyncPrefix}<{descriptor.SourceClassName}, {descriptor.DestinationClassName}>? OnAfterForwardMap;");
                writer.AppendLine(
                    $"public event OnMapHandler{descriptor.AsyncPrefix}<{descriptor.DestinationClassName}, {descriptor.SourceClassName}>? OnAfterReverseMap;");
            }
            else
            {
                writer.AppendLine(
                    $"public event OnMapHandler{descriptor.AsyncPrefix}<{descriptor.SourceClassName}, {descriptor.DestinationClassName}>? OnAfterMap;");
            }

            writer.AppendLine();
            
            writer.AppendXmlDocSummary("The mapper factory");
            writer.AppendLine("protected readonly IMapperFactory? MapperFactory;");
            
            writer.AppendLine("#nullable disable");
            writer.AppendLine();

            // Generate context property if needed
            if (descriptor is { HasContext: true })
            {
                writer.AppendLine("#nullable enable");
                writer.AppendXmlDocSummary("Gets or sets the value of the context");
                writer.AppendLine($"public {descriptor.ContextClassName}? Context {{ get; set; }}");
                writer.AppendLine("#nullable disable");
                writer.AppendLine();
            }

            // Generate constructor if not omitted
            if (!descriptor.OmitConstructor)
            {
                writer.AppendXmlDocSummary($"Initializes a new instance of the {descriptor.MapperClassName} class");
                writer.AppendXmlDocParam("mapperFactory", "The mapper factory for creating nested mappers");
                using (writer.BeginScope($"public {descriptor.MapperClassName}(IMapperFactory mapperFactory)"))
                {
                    writer.AppendLine("MapperFactory = mapperFactory;");
                    writer.AppendLine("AfterConstructor();");
                }

                // Add spacing line using proper CodeWriter methods  
                writer.AppendLine();
            }
        }

        // Generate Map methods
        GenerateMapMethods(writer, descriptor);

        if (descriptor.Index == 0)
        {
            // Generate partial method
            writer.AppendXmlDocSummary("Called after the constructor completes to allow custom initialization");
            writer.AppendLine("partial void AfterConstructor();");
            writer.AppendLine();
        }

        // Generate invoke handler methods
        GenerateInvokeHandlerMethods(writer, descriptor);
    }

    private static void GenerateMapMethods(CodeWriter writer, MapperDescriptor descriptor)
    {
        var returnTypeName = descriptor.IsAsync
            ? $"Task<{descriptor.DestinationClassName}?>"
            : $"{descriptor.DestinationClassName}?";
        var cancellationParam = descriptor.IsAsync ? ", CancellationToken cancellationToken = default" : "";
        var cancellationArg = descriptor.IsAsync ? ", cancellationToken" : "";
        var awaitKeyword = descriptor.IsAsync ? "await " : "";
        var asyncKeyword = descriptor.IsAsync ? "async " : "";

        // First Map method
        writer.AppendLine("#nullable enable");
        writer.AppendXmlDocSummary($"Maps a {descriptor.SourceClassName} to a new {descriptor.DestinationClassName}");
        writer.AppendXmlDocParam("source", "The source object to map from");
        if (descriptor.IsAsync)
        {
            writer.AppendXmlDocParam("cancellationToken", "Cancellation token");
        }

        writer.AppendXmlDocReturns($"A new {descriptor.DestinationClassName} with mapped values");
        using (writer.BeginScope(
                   $"public virtual {returnTypeName} Map{descriptor.AsyncPrefix}({descriptor.SourceClassName}? source{cancellationParam})"))
        {
            writer.AppendLine(
                $"return Map{descriptor.AsyncPrefix}(source, new {descriptor.DestinationClassName}(){cancellationArg});");
        }

        writer.AppendLine("#nullable disable");
        writer.AppendLine();

        // Second Map method
        writer.AppendLine("#nullable enable");
        writer.AppendXmlDocSummary(
            $"Maps a {descriptor.SourceClassName} to an existing {descriptor.DestinationClassName}");
        writer.AppendXmlDocParam("source", "The source object to map from");
        writer.AppendXmlDocParam("destination", "The destination object to map to");
        if (descriptor.IsAsync)
        {
            writer.AppendXmlDocParam("cancellationToken", "Cancellation token");
        }

        writer.AppendXmlDocReturns($"The updated destination object");
        using (writer.BeginScope(
                   $"public virtual {asyncKeyword}{returnTypeName} Map{descriptor.AsyncPrefix}({descriptor.SourceClassName}? source, {descriptor.DestinationClassName}? destination{cancellationParam})"))
        {
            using (writer.BeginScope("if (source == null)"))
            {
                writer.AppendLine("return null;");
            }

            writer.AppendLine();

            using (writer.BeginScope("if (destination == null)"))
            {
                writer.AppendLine($"return {awaitKeyword}Map{descriptor.AsyncPrefix}(source{cancellationArg});");
            }

            var direction = string.Empty;
            if (descriptor.IsBidirectional)
            {
                direction = descriptor.Index == 0 ? "Forward" : "Reverse";
            }
            
            // Generate event invocation
            var invokeMethod = descriptor.IsAsync ? $"Invoke{direction}HandlerAsync" : $"Invoke{direction}Handler";
            var awaitInvoke = descriptor.IsAsync ? "await " : "";
            var beforeMethodName = $"OnBefore{direction}Map";
            
            writer.AppendLine(
                $"{awaitInvoke}{invokeMethod}({beforeMethodName}, new MapEventArgs<{descriptor.SourceClassName}, {descriptor.DestinationClassName}>(source, destination));");
            writer.AppendLine();

            // Generate property mappings
            GeneratePropertyMappings(writer, descriptor);

            // Generate after event invocation
            var afterMethodName = $"OnAfter{direction}Map";

            writer.AppendLine(
                $"{awaitInvoke}{invokeMethod}({afterMethodName}, new MapEventArgs<{descriptor.SourceClassName}, {descriptor.DestinationClassName}>(source, destination));");
            writer.AppendLine();
            writer.AppendLine("return destination;");
        }

        writer.AppendLine("#nullable disable");
        writer.AppendLine();
    }

    private static void GeneratePropertyMappings(CodeWriter writer, MapperDescriptor descriptor)
    {
        var srcProperties = GetProperties(descriptor.SourceClass);
        var destProperties = GetProperties(descriptor.DestinationClass);

        foreach (var destProperty in destProperties)
        {
            WritePropertySet(writer, descriptor, srcProperties, destProperty);
        }
    }

    private static void GenerateInvokeHandlerMethods(CodeWriter writer, MapperDescriptor descriptor)
    {
        var direction = string.Empty;
        if (descriptor.IsBidirectional)
        {
            direction = descriptor.Index == 0 ? "Forward" : "Reverse";
        }
        
        if (descriptor.IsAsync)
        {
            writer.AppendLine("#nullable enable");
            using (writer.BeginScope(
                       $"private async Task Invoke{direction}HandlerAsync(OnMapHandlerAsync<{descriptor.SourceClassName}, {descriptor.DestinationClassName}>? handler, MapEventArgs<{descriptor.SourceClassName}, {descriptor.DestinationClassName}> eventArgs)"))
            {
                using (writer.BeginScope("if (handler == null)"))
                {
                    writer.AppendLine("return;");
                }

                writer.AppendLine();

                writer.AppendLine("var invocationList = handler.GetInvocationList();");
                writer.AppendLine("var handlerTasks = new Task[invocationList.Length];");
                writer.AppendLine();

                using (writer.BeginScope("for (var i = 0; i < invocationList.Length; i++)"))
                {
                    writer.AppendLine(
                        $"var invocationItem = Delegate.CreateDelegate(typeof(Func<object, MapEventArgs<{descriptor.SourceClassName}, {descriptor.DestinationClassName}>, Task>),");
                    writer.AppendLine("    invocationList[i].Target, invocationList[i].Method);");
                    writer.AppendLine(
                        $"handlerTasks[i] = ((Func<object, MapEventArgs<{descriptor.SourceClassName}, {descriptor.DestinationClassName}>, Task>)invocationItem)(this, eventArgs);");
                }

                writer.AppendLine();
                writer.AppendLine("await Task.WhenAll(handlerTasks);");
            }

            writer.AppendLine("#nullable disable");
        }
        else
        {
            // Generate InvokeHandler using proper CodeWriter methods
            writer.AppendLine("#nullable enable");
            using (writer.BeginScope(
                       $"private void Invoke{direction}Handler(OnMapHandler<{descriptor.SourceClassName}, {descriptor.DestinationClassName}>? handler, MapEventArgs<{descriptor.SourceClassName}, {descriptor.DestinationClassName}> eventArgs)"))
            {
                using (writer.BeginScope("if (handler == null)"))
                {
                    writer.AppendLine("return;");
                }

                writer.AppendLine();
                writer.AppendLine("handler(this, eventArgs);");
            }

            writer.AppendLine("#nullable disable");
        }
    }

    private static void WritePropertySet(CodeWriter writer, MapperDescriptor descriptor,
        IList<IPropertySymbol> srcProperties, IPropertySymbol destProperty)
    {
        var mapFrom = destProperty
            .GetAttributes()
            .FirstOrDefault(o => o.AttributeClass?.FullName() == "eQuantic.Mapper.Attributes.MapFromAttribute");
        var mapWhen = destProperty
            .GetAttributes()
            .FirstOrDefault(o => o.AttributeClass?.FullName() == "eQuantic.Mapper.Attributes.MapWhenAttribute");
        
        var mapFromSrcClass = (INamedTypeSymbol?)mapFrom?.ConstructorArguments[0].Value;
        var mapFromSrcPropNames = GetPropertyNamesFromAttribute(mapFrom);

        // Check if we need conditional mapping
        var condition = GetConditionFromMapWhen(mapWhen, srcProperties, descriptor);
        var hasCondition = !string.IsNullOrEmpty(condition);
        
        if (hasCondition)
        {
            writer.BeginScope($"if ({condition})");
        }

        if (mapFromSrcClass != null && mapFromSrcClass.FullName() == descriptor.SourceClass.FullName())
        {
            // Handle multiple properties with aggregation
            if (mapFromSrcPropNames.Length > 1 && mapFrom != null)
            {
                WriteAggregatedPropertySet(writer, descriptor, srcProperties, destProperty, mapFrom);
                if (hasCondition) writer.EndScope();
                return;
            }

            // Handle single property mapping (including nested properties)
            if (mapFromSrcPropNames.Length == 1)
            {
                var propName = mapFromSrcPropNames[0];

                if (propName.Contains('.'))
                {
                    // Nested property (e.g., "Address.Number")
                    WriteNestedPropertySetWithPath(writer, descriptor, propName, destProperty);
                    if (hasCondition) writer.EndScope();
                    return;
                }

                // Simple property
                var mapFromSrcProperty = srcProperties.FirstOrDefault(o =>
                    string.Equals(o.Name, propName, StringComparison.InvariantCultureIgnoreCase));

                if (mapFromSrcProperty != null)
                {
                    WritePropertySet(writer, descriptor, mapFromSrcProperty, destProperty);
                    if (hasCondition) writer.EndScope();
                    return;
                }
            }
        }

        var srcProperty = srcProperties.FirstOrDefault(o =>
            o.Name.Equals(destProperty.Name, StringComparison.InvariantCultureIgnoreCase));

        if (srcProperty != null)
        {
            WritePropertySet(writer, descriptor, srcProperty, destProperty);
        }
        
        if (hasCondition)
        {
            writer.EndScope();
        }
    }

    private static void WritePropertySet(CodeWriter writer, MapperDescriptor descriptor, IPropertySymbol srcProperty,
        IPropertySymbol destProperty)
    {
        var context = new PropertyMappingContext
        {
            SourceProperty = srcProperty,
            DestinationProperty = destProperty,
            VerifyNullability = descriptor.VerifyNullability,
            IsAsync = descriptor.IsAsync,
            SourceVariableName = "source",
            DestinationVariableName = "destination"
        };

        // Use the writer directly without creating new instance - indentation is already set
        PropertyStrategyFactory.GenerateMapping(context, writer);
    }

    // Copy the remaining helper methods from MapperTemplate.partial.cs
    private static void WriteNestedPropertySetWithPath(CodeWriter writer, MapperDescriptor descriptor,
        string propertyPath, IPropertySymbol destProperty)
    {
        // Generate assignment for nested property with proper nullability checks
        var nullabilityCheck = descriptor.VerifyNullability &&
                               (destProperty.Type.CanBeReferencedByName ||
                                destProperty.NullableAnnotation == NullableAnnotation.Annotated);

        // Use the writer directly without creating new instance - indentation is already set by caller
        if (nullabilityCheck)
        {
            var nullCheck = BuildNestedNullabilityCheck(propertyPath);
            var propertyAccessor = BuildNestedPropertyAccessorWithoutNullCheck(propertyPath);

            // For string properties, also check if the value is not null or empty
            var isStringProperty = destProperty.Type.IsString();
            if (isStringProperty)
            {
                nullCheck += $" && !string.IsNullOrEmpty({propertyAccessor})";
            }

            using (writer.BeginScope($"if ({nullCheck})"))
            {
                writer.AppendLine($"destination.{destProperty.Name} = {propertyAccessor};");
            }
        }
        else
        {
            // Use null-conditional operators when not doing explicit nullability checks
            // But handle nullable to non-nullable conversions
            var propertyAccessor = BuildNestedPropertyAccessor(propertyPath);

            // Check if we need to handle nullable to non-nullable conversion
            if (!destProperty.Type.IsNullable())
            {
                if (destProperty.Type.IsString())
                {
                    writer.AppendLine($"destination.{destProperty.Name} = {propertyAccessor} ?? string.Empty;");
                }
                else if (destProperty.Type.IsNumeric() || destProperty.Type.IsBoolean() ||
                         destProperty.Type.Is<Guid>() || destProperty.Type.Is<DateTime>())
                {
                    var defaultValue = destProperty.Type.GetDefaultValue();
                    writer.AppendLine($"destination.{destProperty.Name} = {propertyAccessor} ?? {defaultValue};");
                }
                else
                {
                    writer.AppendLine($"destination.{destProperty.Name} = {propertyAccessor} ?? default;");
                }
            }
            else
            {
                writer.AppendLine($"destination.{destProperty.Name} = {propertyAccessor};");
            }
        }
    }

    private static void WriteAggregatedPropertySet(CodeWriter writer, MapperDescriptor descriptor,
        IList<IPropertySymbol> srcProperties, IPropertySymbol destProperty, AttributeData mapFromAttribute)
    {
        var mapFromSrcPropNames = GetPropertyNamesFromAttribute(mapFromAttribute);
        var aggregationValue = mapFromAttribute.ConstructorArguments.Length > 2
            ? (int)mapFromAttribute.ConstructorArguments[2].Value!
            : 0; // 0 = None
        var separator = mapFromAttribute.ConstructorArguments.Length > 3
            ? (string?)mapFromAttribute.ConstructorArguments[3].Value
            : null;

        // Handle both simple properties and nested properties (with dots)
        var propertyAccessors = new List<string>();
        var propertyPaths = new List<string>(); // Keep track of original paths for nullability checks

        foreach (var propName in mapFromSrcPropNames)
        {
            if (propName.Contains('.'))
            {
                // Nested property (e.g., "Address.Number")
                var accessor = BuildNestedPropertyAccessor(propName);

                if (string.IsNullOrEmpty(accessor))
                    continue;

                propertyAccessors.Add(accessor);
            }
            else
            {
                // Simple property
                var matchedProperty = srcProperties.FirstOrDefault(p =>
                    string.Equals(p.Name, propName, StringComparison.InvariantCultureIgnoreCase));

                if (matchedProperty == null)
                    continue;

                propertyAccessors.Add($"source.{matchedProperty.Name}");
            }

            propertyPaths.Add(propName);
        }

        if (!propertyAccessors.Any())
            return;

        // Generate aggregation code directly with property accessors
        GenerateAggregationCodeWithAccessors(writer, descriptor, propertyAccessors, propertyPaths, destProperty,
            aggregationValue, separator);
    }

    // Copy all the helper methods from MapperTemplate.partial.cs
    private static string GetConditionFromMapWhen(AttributeData? mapWhenAttribute, IList<IPropertySymbol> srcProperties, MapperDescriptor descriptor)
    {
        if (mapWhenAttribute == null || mapWhenAttribute.ConstructorArguments.Length < 1)
            return string.Empty;

        var firstArg = mapWhenAttribute.ConstructorArguments[0];
        if (firstArg.Value is not string condition)
            return string.Empty;

        // Check if it's an expression (second argument is true)
        var isExpression = mapWhenAttribute.ConstructorArguments.Length > 1 && 
                          mapWhenAttribute.ConstructorArguments[1].Value is true;

        if (isExpression)
        {
            // Return the expression as-is, but check for Context references
            // Examples: "Context?.IncludeSensitiveData == true", "source.Age >= 18"
            
            // If the expression contains Context but mapper doesn't have context, return empty (skip mapping)
            if (condition.Contains("Context") && !descriptor.HasContext)
            {
                return string.Empty;
            }
            
            return condition;
        }
        else
        {
            // It's a simple property name, check if it exists and build the condition
            var property = srcProperties.FirstOrDefault(p => 
                string.Equals(p.Name, condition, StringComparison.InvariantCultureIgnoreCase));
            
            if (property != null)
            {
                // For boolean properties, just check if true
                if (property.Type.IsBoolean())
                {
                    return $"source.{property.Name} == true";
                }
                // For nullable booleans
                else if (property.Type.IsNullableBoolean())
                {
                    return $"source.{property.Name} == true";
                }
                // For other types, check if not null/empty
                else if (property.Type.IsString())
                {
                    return $"!string.IsNullOrEmpty(source.{property.Name})";
                }
                else
                {
                    return $"source.{property.Name} != null";
                }
            }
            
            // If property not found, try nested property path
            if (condition.Contains('.'))
            {
                return $"{BuildNestedPropertyAccessor(condition)} == true";
            }
        }

        return string.Empty;
    }
    
    private static string[] GetPropertyNamesFromAttribute(AttributeData? mapFromAttribute)
    {
        if (mapFromAttribute == null || mapFromAttribute.ConstructorArguments.Length < 2)
            return [];

        var secondArg = mapFromAttribute.ConstructorArguments[1];

        // Check if it's an array (new syntax)
        if (secondArg is { IsNull: false, Kind: TypedConstantKind.Array })
        {
            return secondArg.Values.Select(v => v.Value?.ToString()).Where(v => v != null).ToArray()!;
        }

        // Check if it's a single string (old syntax for backward compatibility)
        if (!secondArg.IsNull && secondArg.Value is string singleProperty)
        {
            return [singleProperty];
        }

        return [];
    }

    private static string BuildNestedPropertyAccessor(string propertyPath)
    {
        // Build nested property accessor with null checking
        // e.g., "Address.Number" becomes "source.Address?.Number"
        var parts = propertyPath.Split('.');
        if (parts.Length < 2) return string.Empty;

        var accessor = "source";
        for (var i = 0; i < parts.Length; i++)
        {
            if (i == parts.Length - 1)
            {
                // Last property - no null check needed
                accessor += $".{parts[i]}";
            }
            else
            {
                // Intermediate properties - add null check
                accessor += $".{parts[i]}?";
            }
        }

        return accessor;
    }

    private static string BuildNestedNullabilityCheck(string propertyPath)
    {
        // Build null checks for nested properties
        // e.g., "Address.Country.Name" becomes "source != null && source.Address != null && source.Address.Country != null"
        var parts = propertyPath.Split('.');
        if (parts.Length < 2) return "source != null";

        var checks = new List<string> { "source != null" };
        var currentPath = "source";

        for (var i = 0; i < parts.Length - 1; i++)
        {
            currentPath += $".{parts[i]}";
            checks.Add($"{currentPath} != null");
        }

        return string.Join(" && ", checks);
    }

    private static string BuildNestedPropertyAccessorWithoutNullCheck(string propertyPath)
    {
        // Build property accessor without null-conditional operators for use inside null checks
        // e.g., "Address.Number" becomes "source.Address.Number"
        var parts = propertyPath.Split('.');
        if (parts.Length < 2) return string.Empty;

        return "source." + string.Join(".", parts);
    }

    private static void GenerateAggregationCodeWithAccessors(CodeWriter writer, MapperDescriptor descriptor,
        List<string> propertyAccessors, List<string> propertyPaths, IPropertySymbol destProperty, int aggregationValue,
        string? separator)
    {
        var propertyAccess = string.Join(", ", propertyAccessors);
        var nullabilityCheck = descriptor.VerifyNullability &&
                               (destProperty.Type.CanBeReferencedByName ||
                                destProperty.NullableAnnotation == NullableAnnotation.Annotated);

        // Use the writer directly without creating new instance - indentation is already set by caller

        // Helper method to handle nullable to non-nullable conversion for aggregation results
        string GetAggregationAssignment(string expression, bool canReturnNull = false)
        {
            if (canReturnNull && !destProperty.Type.IsNullable())
            {
                if (destProperty.Type.IsString())
                {
                    return $"destination.{destProperty.Name} = ({expression}) ?? string.Empty;";
                }
                else if (destProperty.Type.IsNumeric() || destProperty.Type.IsBoolean() ||
                         destProperty.Type.Is<Guid>() || destProperty.Type.Is<DateTime>())
                {
                    var defaultValue = destProperty.Type.GetDefaultValue();
                    return $"destination.{destProperty.Name} = ({expression}) ?? {defaultValue};";
                }
                else
                {
                    return $"destination.{destProperty.Name} = ({expression}) ?? default;";
                }
            }
            else
            {
                return $"destination.{destProperty.Name} = {expression};";
            }
        }

        var code = aggregationValue switch
        {
            1 => GetAggregationAssignment(
                $"string.Join(\"\", new object?[] {{ {propertyAccess} }}.Where(x => x != null && !string.IsNullOrEmpty(x.ToString())).Select(x => x.ToString()))"), // Concatenate - string.Join never returns null
            2 => GetAggregationAssignment(
                $"string.Join(\" \", new object?[] {{ {propertyAccess} }}.Where(x => x != null && !string.IsNullOrEmpty(x.ToString())).Select(x => x.ToString()))"), // ConcatenateWithSpace
            3 => GetAggregationAssignment(
                $"string.Join(\", \", new object?[] {{ {propertyAccess} }}.Where(x => x != null && !string.IsNullOrEmpty(x.ToString())).Select(x => x.ToString()))"), // ConcatenateWithComma
            4 => GetAggregationAssignment(
                $"string.Join(\"{separator ?? ""}\", new object?[] {{ {propertyAccess} }}.Where(x => x != null && !string.IsNullOrEmpty(x.ToString())).Select(x => x.ToString()))"), // ConcatenateWithSeparator
            5 => GetAggregationAssignment($"new[] {{ {propertyAccess} }}.Sum()"), // Sum
            6 => GetAggregationAssignment($"new[] {{ {propertyAccess} }}.Max()"), // Max
            7 => GetAggregationAssignment($"new[] {{ {propertyAccess} }}.Min()"), // Min
            8 => GetAggregationAssignment($"new[] {{ {propertyAccess} }}.Average()"), // Average
            9 => GetAggregationAssignment(
                $"new object?[] {{ {propertyAccess} }}.Where(x => x != null && !string.IsNullOrEmpty(x.ToString())).FirstOrDefault()?.ToString()",
                true), // FirstNonEmpty - can return null
            10 => GetAggregationAssignment(
                $"new object?[] {{ {propertyAccess} }}.Where(x => x != null && !string.IsNullOrEmpty(x.ToString())).LastOrDefault()?.ToString()",
                true), // LastNonEmpty - can return null
            11 => GetAggregationAssignment($"new object?[] {{ {propertyAccess} }}.Count(x => x != null)"), // Count
            _ => string.Empty
        };

        if (nullabilityCheck && !string.IsNullOrEmpty(code))
        {
            // Generate comprehensive null checks for all nested properties
            var allNullChecks = new List<string> { "source != null" };

            foreach (var path in propertyPaths)
            {
                if (!path.Contains('.'))
                    continue;

                // For nested properties, add all intermediate null checks
                var parts = path.Split('.');
                var currentPath = "source";

                for (var i = 0; i < parts.Length - 1; i++)
                {
                    currentPath += $".{parts[i]}";
                    if (!allNullChecks.Contains($"{currentPath} != null"))
                    {
                        allNullChecks.Add($"{currentPath} != null");
                    }
                }
            }

            var combinedNullCheck = string.Join(" && ", allNullChecks);

            using (writer.BeginScope($"if ({combinedNullCheck})"))
            {
                writer.AppendLine(code);
            }
        }
        else
        {
            writer.AppendLine(code);
        }
    }

    private static List<IPropertySymbol> GetProperties(ITypeSymbol? sourceClass)
    {
        if (sourceClass == null) return [];

        var list = GetProperties(sourceClass.BaseType);
        list.AddRange(sourceClass.ReadWriteScalarProperties());
        return list;
    }

    private static string GetClassName(INamedTypeSymbol namedTypeSymbol)
    {
        var classFullNamespace = namedTypeSymbol.FullNamespace();
        if (classFullNamespace!.Contains($".{namedTypeSymbol.Name}.") ||
            classFullNamespace.EndsWith($".{namedTypeSymbol.Name}"))
            return $"{classFullNamespace}.{namedTypeSymbol.Name}";
        return namedTypeSymbol.Name;
    }

    private HashSet<string> GetNamespaces()
    {
        var namespaces = new HashSet<string>
        {
            "System",
            "System.Collections.Generic",
            "System.Linq",
            "eQuantic.Mapper"
        };
        if (asynchronous)
            namespaces.Add("System.Threading.Tasks");

        var srcClassFullNamespace = mapperInfo.SourceClass.FullNamespace();
        if (!string.IsNullOrEmpty(srcClassFullNamespace))
        {
            namespaces.Add(srcClassFullNamespace!);
        }

        var destClassFullNamespace = mapperInfo.DestinationClass.FullNamespace();
        if (!string.IsNullOrEmpty(destClassFullNamespace))
        {
            namespaces.Add(destClassFullNamespace!);
        }

        // Clear processed types for each mapper generation
        ProcessedTypes.Clear();

        var srcProperties = GetPropertiesNamespaces(mapperInfo.SourceClass);
        foreach (var srcPropertyNamespace in srcProperties)
        {
            if (!string.IsNullOrEmpty(srcPropertyNamespace))
                namespaces.Add(srcPropertyNamespace);
        }

        var destProperties = GetPropertiesNamespaces(mapperInfo.DestinationClass);
        foreach (var destPropertyNamespace in destProperties)
        {
            if (!string.IsNullOrEmpty(destPropertyNamespace))
                namespaces.Add(destPropertyNamespace);
        }

        return namespaces;
    }

    private static IEnumerable<string> GetPropertiesNamespaces(ITypeSymbol classType)
    {
        var namespaces = new HashSet<string>();
        var typeFullName = classType.TryFullName();

        // Prevent circular references by checking if we've already processed this type
        if (typeFullName != null && ProcessedTypes.Contains(typeFullName))
        {
            return namespaces;
        }

        if (typeFullName != null)
        {
            ProcessedTypes.Add(typeFullName);
        }

        var list = classType.ReadWriteScalarProperties();
        foreach (var symbol in list)
        {
            if (symbol.Type.IsPrimitive())
                continue;

            if (symbol.Type is INamedTypeSymbol namedTypeSymbol && namedTypeSymbol.TypeArguments.Any())
            {
                foreach (var ts in namedTypeSymbol.TypeArguments)
                {
                    var nmSpace = ts.FullNamespace();
                    if (!string.IsNullOrEmpty(nmSpace))
                        namespaces.Add(nmSpace!);

                    // Only recurse if we haven't processed this type yet
                    var tsFullName = ts.TryFullName();

                    if (tsFullName == null || ProcessedTypes.Contains(tsFullName))
                        continue;

                    var propertyNamespaces = GetPropertiesNamespaces(ts);
                    foreach (var propertyNamespace in propertyNamespaces)
                    {
                        namespaces.Add(propertyNamespace);
                    }
                }
            }

            var fullNamespace = symbol.Type.FullNamespace();
            if (string.IsNullOrEmpty(fullNamespace))
                continue;

            namespaces.Add(fullNamespace!);
        }

        return namespaces;
    }
}